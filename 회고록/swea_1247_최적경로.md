# swea 1247 최적경로 

## 풀이과정: 

회사에서 고객 모두 방문하고, 집 돌아가는 경로 중에서 가장 짧은 거 찾는다길래 

최단경로 문제네 -> bfs? -> 그런데 100 x 100 행렬에 좌표 찍고 bfs 하기에는 서로 인접하지 않을 수 있다고 생각이 들었다. 

그럼 N개의 고객 집들의 좌표를 순열로 순서를 구하고, 회사 - 고객 집들 - 내 집 사이의 거리를 더해서 최소 거리를 그때마다 업데이트하면 어떨까 생각했다. 

근데 순열이니까 10!이고, 이건 30만 정도의 시간 복잡도가 발생하는데, 제한 시간이 20초로 충분히 커버가 가능하다고 생각이 들었다. 

그래서 순열로 시작함

## 순열로 푸는 과정에서 어려웠던 점: 

- 배열 b의 크기를 어떻게 해야 할까 N개만? N+2개를? 
- visited로 해당 지점을 방문했는지 체크하려고 했는데 `visited[cnt]`라고 자꾸만 쓴다;; visited는 선택 여부를 보기 때문에, cnt는 depth이고, 따라서 `visited[i]`가 맞다. 제발 ㅠㅠ

## 개선된 풀이: 걸린 시간은 동일했음 

- 나는 homes를 따로 두고, 거기에 집 좌표들만 넣고 -> 하나씩 get(i) 하면서 거리를 계산했었다.
- 근데, 그때마다 계산하면 분명 중복된 계산이 존재할 거기 때문에
- 미리 집집마다 맨허튼 거리를 계산해두면 좋다는 것.
- 따라서 `dist` <- new int[N+2][N+2]; 이중 반복문 i,j에 대해서 맨허튼 거리 계산
- 이렇게 계산된 거리 배열에 대해서,
- `dfs(depth, last, sum)` 으로 실행을 하면 된다.
  - 누적합을 sum에 저장해두고, depth는 N이 되면 멈춰서 마지막 내 집과 last의 거리를 구해서 더하면 된다.
  - 그 외에는 내가 푼 순열과 동작방식이 같다.
 
## 느낀 점

- 알고리즘별로 코드 정리를 다시 해야 될 것 같다. 자꾸 섞여서 계산한다.
- 이래저래 할 게 많으니까 모든 걸 자꾸만 조급하게 풀고 계산하고 틀리지 않아도 되는 거에서 혼동하는 것 같다 ㅠ 차분하게 좀 풀어 좀~~
