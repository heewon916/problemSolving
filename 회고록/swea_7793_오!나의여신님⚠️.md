## ⭐⭐ swea 7793 오! 나의 여신님

> ⚠️ 처음 풀이: 틀림

```plain
// 나의 아키텍쳐:
최단경로 => bfs
1초마다
1. *은 상하좌우로
2. S의 위치 이동은 큐에 넣자
- X면 안되고, *도 아니면 갈 수 있다.
```

악마의 손아귀가 1초에 상하좌우로 퍼지고, 동시에 수연이도 상하좌우 인접칸으로 움직이니까

- 큐 하나에 수연이의 위치만 모니터링 하면 된다고 생각했다.

그래서 큐가 빌 때까지 아래 과정을 반복하면 된다고 생각했다.

- 한 번 돌 때, '\*'인 곳에 대해서 4방 탐색의 반복

```java
for(int i=0; i<N; i++) {
  for(int j=0; j<M; j++) {
    if(mat[i][j] == '*') devil(i, j);
  }
}
...
static void devil(int i, int j) {
  for(int d=0; d<4; d++) {
    int ni = i+dx[d], nj = j+dy[d];
    if(0<=ni && ni<N && 0<=nj && nj<M) {
      if(mat[i][j] == 'D' || mat[i][j] == 'X') continue;
      mat[ni][nj] = '*';
    }
  }
}
```

그 뒤에서야 S가 갈 수 있는 곳이 어디일까 찾으면 된다고 생각했다.

- q에 들어간 만큼 for문을 돌려서, 같은 너비(== 같은 시간)에 대해서 모두 갈 수 있는 곳을 찾아보자였다.
- 그렇지만.. 머리에 쥐가 나면서 더이상 아이디어가 떠오르지 않았다😢 결국 GPT에게 물어봐서 아래와 같은 코드를 알게 되었다.

```java
int qSize = q.size();
for(int i=0; i<qSize; i++) {
  // 큐의 정점을 뽑고
  int[] cur = q.poll();
  // 그게 목적지이면 빼고
  if(mat[cur[0]][cur[1]] == 'D') {
    able = true;
    break;
  }
  // 아니라면, 주변 4방탐색을 하면서 갈 수 있는 곳을 큐에 모두 넣는다.
  for(int d=0; d<4; d++) {
    int nx = cur[0] + dx[d];
    int ny = cur[1] + dy[d];
    // 조건. 1) 범위 2) *이거나 X이면 못감 3) 방문 안한 곳이어야 함
    if(0<=nx && nx<N && 0<=ny && ny<M) {
      if(v[nx][ny] || mat[nx][ny] == '*' || mat[nx][ny] == 'X') continue;
      q.add(new int[] {nx, ny});
      v[nx][ny] = true;
    }
  }
}

```

> ✅ 정답풀이: GPT 도움 받음

⚠️ 풀이의 포인트

- \*이 확산되는 위치와 시간을 S를 움직이면서 함께 계산하는 게 아니라,
- 따로 devTime 배열을 만들어서 어느 좌표가 어느 time에 확산되는지를 미리 계산해둔다.
- 그리고, S의 이동은 bfs로 풀이하되, `x, y, t`를 큐에 넣는다.
  - t는 언제 그 좌표에 이르는지를 기록한다.
- 'D'를 만나면 종료하고
- 아니면 `devTime[nx][ny] > nt` 일 때만 (S가 가는 시간이 확산되는 시점보다 이르면 갈 수 있으므로) 그곳에 방문할 수 있으므로, 방문처리 및 offer를 해주면 된다.
