## ⭐ swea 1861 정사각형 방

### ⚠️ 어려웠던 점

- 연속된 길이를 구하는 거에서 dfs를 떠올렸다. dfs 함수 구현 중, 길이를 세기 위해서 cnt를 매개변수로 처음에 전달했다. 그래서 재 호출할때마다 cnt+1 로 값을 넘겨주려 했다. 근데 cnt 값이 계속 0이 나오는 문제로 이어졌다.

```java
static int dfs(int[][] mat, int sx, int sy, boolean[][] v, int N, int cnt) {
  // cnt를 반환하는 기저조건에 문제
  v[sx][sy] = true;
  for(int d=0; d<4; d++) {
    int nx = sx+dx[d], ny = sy+dy[d];
    if(0<=nx && nx<N && 0<=ny && ny<N) {
      if(!v[nx][ny] && (mat[sx][sy]+1 == mat[nx][ny])) {
        dfs(mat, nx, ny, v, N, cnt+1);
        }
      }
    }
    return cnt;
}
```

GPT에게 힌트를 얻어보니, 아래의 조언을 얻었다.

- 반환값을 버리고 있었고,
- visited 또한 필요하지 않다.

반환값을 버리지 않기 위해선 dfs 안에서 변수 선언이 아닌, cnt = dfs().. 의 형태가 필요하다.
이렇게 되면 내가 cnt가 버려지지 않고 반영된다.

또한 visited가 필요하지 않은 이유는 배열 안에 숫자가 모두 다르다고 했고, 1만큼 큰 위치로만 가기 때문에 재방문될 일이 없다.

따라서 아래처럼 풀이 할 수 있었다.

```java
static int dfs(int[][] mat, int sx, int sy, int N) {
  int cnt = 1;
  for(int d=0; d<4; d++) {
    int nx = sx+dx[d], ny = sy+dy[d];
    if(0<=nx && nx<N && 0<=ny && ny<N) {
      if(mat[sx][sy]+1 == mat[nx][ny]) {
        cnt = Math.max(cnt, 1+dfs(mat, nx, ny, N));
      }
    }
  }
  return cnt;
}
```

---

BFS로도 풀이할 수 있다.

```java
static int bfs(int[][] mat, int sx, int sy, int N) {
  int cnt = 1;
  ArrayDeque<int[]> q = new ArrayDeque<>();
  q.add(new int[] {sx, sy});
  while(!q.isEmpty()) {
    int[] cur = q.poll();
    int cx = cur[0], cy = cur[1];
    for(int d=0; d<4; d++) {
      int nx = cx+dx[d], ny = cy+dy[d];
      if(0<=nx && nx<N && 0<=ny && ny<N) {
        if(mat[cx][cy]+1 == mat[nx][ny]) {
          cnt++;
          q.add(new int[] {nx, ny});
          break;
        }
      }
    }
  }
  return cnt;
}
```

### ✅ 배운 점 - DP로 풀이하는 것

dp는 결국 누적합의 일종이기 때문에 cnt 변수를 따로 선언하지 않는다.

우선 dfs이므로 가지치기를 해야 한다.

- 이미 계산된 길은 dp 값을 불러오는 것이 기저조건이 된다.

아닌 경우에는 1로 초기화하고, dp의 값을 초기화하는 과정이 포인트

```java
static int  dfsDp(int[][] mat, int[][] dp, int sx, int sy,int N) {
  if(dp[sx][sy] != 0) return dp[sx][sy];

  dp[sx][sy] = 1;
  for(int d=0; d<4; d++) {
    int nx = sx+dx[d], ny = sy+dy[d];
    if(0<=nx && nx<N && 0<=ny && ny<N) {
      if(mat[sx][sy]+1 == mat[nx][ny]) {
        dp[sx][sy] = 1 + dfsDp(mat, dp, nx, ny, N);
        break;
      }
    }
  }
  return dp[sx][sy];
}
```