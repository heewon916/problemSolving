# 20250815 회고록

## ⭐bj 17471 게리 멘더링
> 풀이 방식(사진 참고)

문제의 요구사항
- 구역을 2개로 나누는데, 인구 수 차이를 MAX로 만들어라. 
- 각 구역은 반드시 1개 이상의 정점을 포함해야 한다. 
- 구역 내 정점들은 모두 연결되어 있어야 한다. 

우선, 주어지는 입력에서 그래프가 간선 중심이어서 인접 리스트로 선언하였다. 

구역을 2개로 나눠야 한다는 점에서, 조합을 떠올렸고 

각 도시를 0 또는 1로 분리한 뒤, 그룹 0과 그룹 1 각각에 대해서 
- 각 그룹이 연결되어 있는지 확인하고 
- true라면 인구 수를 각각 연결한 뒤, diff를 구해 minDiff(초기화; MAX_VALUE)를 갱신해가면 된다. 

시간 복잡도 확인 
- N은 최대 10; 제한시간 0.5초 = 0.5 * 10^8 
- 나누는 경우의 수는 N개 (<1,9> <2,8>..)
- 한 경우의 대한 조합의 경우의 수는 NC2 = 10C2 = 45 
- 각 조합마다 연결 확인
- 인구수 계산 
- 따라서, N * N^2 * N * N = N^5 = 10^5 
- 제한시간 안에는 돌아갈 듯 하다. 

아이디어 구현까지는 20분 정도 걸린 듯하다.. 

> 풀이 중 어려움 
1. 조합을 만들 때 combMain 배운 걸 그대로 가져다 쓴 것에서의 오류 
    ```java
    static void comb(int cnt, int start, int depth){
        /*
        * @param: cnt; depth 길이만큼만 그룹 형성 
        * @param: start; 어느 정점부터 조합 시작할 것인지 
        * @param: depth; 조합에서 부분집합의 길이가 미정이기 때문에 1부터 N-1까지 필요
        * 조합 만들기: b 배열을 0과 1로 적절히 채워, 그룹을 나눈다. 
        */
        if(cnt == depth) {							// 조합이 만들어지면
            for(int j=0; j<2; j++) {				// 각 그룹이 연결되어 있는지 확인하고, 
                able = checkConnected(j) && able; 	// 두 그룹 모두 true 일 때만 성립 
            }
            // 코드 생략 
        }

        for(int i=start; i<N+1; i++) {	// 조합의 핵심: 백트래킹 
        //	b[cnt] = 1; 		        // 몇 개 골랐냐가 아니라, 어느 위치를 골랐냐가 중요함 
            b[i] = 1; 					// i 위치에 1을 넣고
            comb(cnt+1, i+1, depth);	// 조합 만든 뒤
            able = true; 				
            b[i] = 0; 					// 다시 복구
    }
    ```
    - cnt를 그대로 가져다 썼더니, N=3이라고 가정하면 010도 나와야 하는 것이 100 110 111 이런 것만 나와서 뭐가 문젤까 싶었다. 
    - ✅ cnt의 의미는 몇 개 골랐는가를 센다. 따라서 depth를 체크할 때는 올바른 사용이다. 
    - ✅ 그러나, 이 문제는 **몇 개 골랐는가**가 아닌, **어느 수를 고를 것인가**에 있다. 따라서, `b[i] = 1`로 하는 것이 옳다. 
2. `checkConnected()`함수의 사용 위치 틀림 
    하나의 그룹을 만들 때마다, 그 그룹 안의 정점들이 연결되었는지를 확인해야 한다. 

    처음에는, main문 안에서, `comb(0, 0, i)`가 종료되고 돌아오면 그때 b를 이용하면 될 것이라 생각했다. 

    그런데, 모니터링 코드를 이용해서 보니 턱 없이 적은 조합을 갖고 연결을 확인하길래 무엇이 문제인가 생각하게 되었다. 

    그러나, 하나의 조합은 main문에서 다루는 것이 아니라, `comb`함수의 `if(cnt == depth)`에서 다뤄진다. 따라서, checkConnected는 그리로 옮겨져야 하는 것이 맞고, 그 안에서 인구수 계산까지 완료하는 것이 맞다. 

> 놓친 점 총정리
> - 결국, 논리적인 오류들이었다. 구현 연습을 더 해야 할 것 같다. 어디에 어떤 함수를 어떻게 불러올 때 어떤 결과로 이어지는가라는 사고의 과정을 놓치면 안되는데.. 화이팅⭐


## ⭐bj 14503 로봇청소기 
이전에 한번 풀었던 문제라 그런가.. 풀이가 조금 더 유연해졌다. 
- 참고로 이전 풀이는 `my_homework/bj`에 있다. 

> 이전의 풀이

주변의 4칸 중 청소되지 않은 빈칸이 있고 없고에서 논리 흐름의 차이를 

주변 4칸 순찰하는 것 안에서 해결하려 했다. 그래서인가 코드를 봐도 논리가 꼬인 것 같고 아주 어지러웠다. 

> 현재 풀이 

주변 4칸 순찰 중에 청소되지 않은 빈칸이 1개라도 있다면 `done = false`로 뒀다. 

그리고 for문을 벗어나고 나서, 

`if(done)-else`로 나누어 풀이를 진행하니 코드가 훨씬 가독성이 높아졌다. 

> ⚠️그럼에도 이번 풀이에서 내가 놓친 점 

1. 청소가 다 된 경우, 방향을 유지해야 한다. 그러나, `d = (d+6) % 4`로 코드를 작성하면서, 바라보는 방향이 바뀌어 계속 무한반복을 마주했었다. 혼자서 원인을 찾아내지 못해서 조금 슬프다.
2. 청소 안된 칸이 있는 경우에는, 그 칸을 찾아가야 하기 때문에 `else문`안에서 다시 주변 4칸을 돌며 청소 안된 칸을 찾아야 한다. 여기까지는 저번에 놓친 걸 잘 캐치했다. 
- ⭐그러나, **여러 칸을 찾았다고 해도, 청소기는 원래 자리로 돌아오지 않는다. **이 점을 유의하지 못했다. `clean(nr, nc, d)`한 뒤에, 반드시 `return`해야 한다는 것이다. 

> 문제를 잘 읽자 꼬옥.. 


## bj 1182 부분수열의 합 
부분집합 + 백트래킹 연습할 겸 더 풀어보았다. 

부분집합, 조합 2가지 방법으로 풀었는데, 부분집합 풀이가 걸린 시간이 100ms 정도 낮았다. 

> 부분집합 풀이에서 기억할 것 
- 기저조건 + 언제 return할 것인지를 잘 정해야 한다. 

처음에 잘못 구현했던 부분이 있었는데, 정수들의 합이니 `sum == S`가 true라고 해서 바로 return하면 안되는데 그래버렸다.. 
- 정수이므로, 그 뒤에 음수 + 양수의 적절한 조합으로 또다른 부분수열이 나올 수도 있다! 


> 조합 풀이에서 기억할 것 
- depth를 달리 하면서 조합을 구해야 할 때, 무엇이 현재 depth를 카운트하는 변수인지 잘 체크해야 한다. 
- 또, `b[*] = *;` 에서처럼 각 *에 들어갈 변수가 어떤 의미를 담는지도 세심히 체크해야 한다. 익숙한 대로 cnt, a[i] 넣다간 큰일남. ㅎㅋㅎ

 