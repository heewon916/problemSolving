## ⭐bj 17471 게리 멘더링
> 풀이 방식(사진 참고)

문제의 요구사항
- 구역을 2개로 나누는데, 인구 수 차이를 MAX로 만들어라. 
- 각 구역은 반드시 1개 이상의 정점을 포함해야 한다. 
- 구역 내 정점들은 모두 연결되어 있어야 한다. 

우선, 주어지는 입력에서 그래프가 간선 중심이어서 인접 리스트로 선언하였다. 

구역을 2개로 나눠야 한다는 점에서, 조합을 떠올렸고 

각 도시를 0 또는 1로 분리한 뒤, 그룹 0과 그룹 1 각각에 대해서 
- 각 그룹이 연결되어 있는지 확인하고 
- true라면 인구 수를 각각 연결한 뒤, diff를 구해 minDiff(초기화; MAX_VALUE)를 갱신해가면 된다. 

시간 복잡도 확인 
- N은 최대 10; 제한시간 0.5초 = 0.5 * 10^8 
- 나누는 경우의 수는 N개 (<1,9> <2,8>..)
- 한 경우의 대한 조합의 경우의 수는 NC2 = 10C2 = 45 
- 각 조합마다 연결 확인
- 인구수 계산 
- 따라서, N * N^2 * N * N = N^5 = 10^5 
- 제한시간 안에는 돌아갈 듯 하다. 

아이디어 구현까지는 20분 정도 걸린 듯하다.. 

> 풀이 중 어려움 
1. 조합을 만들 때 combMain 배운 걸 그대로 가져다 쓴 것에서의 오류 
    ```java
    static void comb(int cnt, int start, int depth){
        /*
        * @param: cnt; depth 길이만큼만 그룹 형성 
        * @param: start; 어느 정점부터 조합 시작할 것인지 
        * @param: depth; 조합에서 부분집합의 길이가 미정이기 때문에 1부터 N-1까지 필요
        * 조합 만들기: b 배열을 0과 1로 적절히 채워, 그룹을 나눈다. 
        */
        if(cnt == depth) {							// 조합이 만들어지면
            for(int j=0; j<2; j++) {				// 각 그룹이 연결되어 있는지 확인하고, 
                able = checkConnected(j) && able; 	// 두 그룹 모두 true 일 때만 성립 
            }
            // 코드 생략 
        }

        for(int i=start; i<N+1; i++) {	// 조합의 핵심: 백트래킹 
        //	b[cnt] = 1; 		        // 몇 개 골랐냐가 아니라, 어느 위치를 골랐냐가 중요함 
            b[i] = 1; 					// i 위치에 1을 넣고
            comb(cnt+1, i+1, depth);	// 조합 만든 뒤
            able = true; 				
            b[i] = 0; 					// 다시 복구
    }
    ```
    - cnt를 그대로 가져다 썼더니, N=3이라고 가정하면 010도 나와야 하는 것이 100 110 111 이런 것만 나와서 뭐가 문젤까 싶었다. 
    - ✅ cnt의 의미는 몇 개 골랐는가를 센다. 따라서 depth를 체크할 때는 올바른 사용이다. 
    - ✅ 그러나, 이 문제는 **몇 개 골랐는가**가 아닌, **어느 수를 고를 것인가**에 있다. 따라서, `b[i] = 1`로 하는 것이 옳다. 
2. `checkConnected()`함수의 사용 위치 틀림 
    하나의 그룹을 만들 때마다, 그 그룹 안의 정점들이 연결되었는지를 확인해야 한다. 

    처음에는, main문 안에서, `comb(0, 0, i)`가 종료되고 돌아오면 그때 b를 이용하면 될 것이라 생각했다. 

    그런데, 모니터링 코드를 이용해서 보니 턱 없이 적은 조합을 갖고 연결을 확인하길래 무엇이 문제인가 생각하게 되었다. 

    그러나, 하나의 조합은 main문에서 다루는 것이 아니라, `comb`함수의 `if(cnt == depth)`에서 다뤄진다. 따라서, checkConnected는 그리로 옮겨져야 하는 것이 맞고, 그 안에서 인구수 계산까지 완료하는 것이 맞다. 

> 놓친 점 총정리
> - 결국, 논리적인 오류들이었다. 구현 연습을 더 해야 할 것 같다. 어디에 어떤 함수를 어떻게 불러올 때 어떤 결과로 이어지는가라는 사고의 과정을 놓치면 안되는데.. 화이팅⭐

