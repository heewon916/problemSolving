# 목차 
- [목차](#목차)
- [카운팅 정렬](#카운팅-정렬)
  - [카운팅 정렬 과정](#카운팅-정렬-과정)
    - [1단계: 각 항목의 발생 횟수 세기 =\> 그 발생 횟수를 counts\[\] 에 저장한다.](#1단계-각-항목의-발생-횟수-세기--그-발생-횟수를-counts-에-저장한다)
    - [2단계: 누적 합 계산: 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts 원소 조정함](#2단계-누적-합-계산-각-항목의-앞에-위치할-항목의-개수를-반영하기-위해-counts-원소-조정함)
    - [3단계: 정렬된 배열에 값 채우기](#3단계-정렬된-배열에-값-채우기)
  - [슈도코드](#슈도코드)

# 카운팅 정렬 

✅ 항목들의 순서를 결정하기 위해 집합에서 **각 항목이 몇 개씩 있는지 세는** 작업을 한다 

- 시간복잡도: $O(n + k)$ : n은 리스트 길이, k는 정수의 최댓값 
- 공간복잡도: $O(k)$

✅ 제한사항 

1. 정수나 정수로 표현할 수 있는 자료에 대해서만 적용한다. 

## 카운팅 정렬 과정 

- 주어진 데이터: 0 4 1 3 1 2 4 1 
  
### 1단계: 각 항목의 발생 횟수 세기 => 그 발생 횟수를 counts[] 에 저장한다. 

- counts[i]: 숫자 i의 발생 횟수
- 배열의 크기: **데이터의 최댓값 + 1** 만큼 필요하다.
- counts배열: 1 3 1 1 2


### 2단계: 누적 합 계산: 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts 원소 조정함 

- 각 항목이, 정렬된 배열에서 어디에 위치해야 하는지에 대한 정보 담기 
- '0': 1번째까지, '1': 4번째까지, '2': 5번째까지.. 정렬된 위치 나타냄 

- 기존 counts: [1, 3, 1, 1, 2]
- 누적 합 계산 과정:
  - counts[0] = 1
  - counts[1] = counts[0] + 3 = 1 + 3 = 4
  - counts[2] = counts[1] + 1 = 4 + 1 = 5
  - counts[3] = counts[2] + 1 = 5 + 1 = 6
  - counts[4] = counts[3] + 2 = 6 + 2 = 8
- 결과 counts: [1, 4, 5, 6, 8]

### 3단계: 정렬된 배열에 값 채우기 

- 원본 데이터 **뒤에서부터** 순회하면서
- `counts` 배열을 참고해 정렬된 결과를 담을 `result` 배열에 값을 채워넣는다. 

1. 원본 데이터의 마지막 값 `1` 
   1. `counts[1]`은 `4`이다. 
   2. `result` 배열의 4번째 위치에 `1`을 넣는다. 
   3. `counts[1]--` 
   4. `result = [ , , , 1, , , , ]`
2. 그 다음 마지막 값은 `4`
   1. `counts[4]`은 `8`이다. 
   2. `result` 배열의 8번째 위치에 `4`을 넣는다. 
   3. `counts[4]--` 
   4. `result = [ , , , 1, , , , 4]`
3. 모든 과정을 마치고 나면 => `result: [0, 1, 1, 1, 2, 3, 4, 4]`

## 슈도코드 
```java
countingSort(A, B, K) 
// k: 배열 원소 중 최댓값 
// A[1..n]: 입력배열 (값은 1 to k)
// B[1..n]: 정렬된 배열
// C[1..K]: 카운트 배열 

// 1. counts 배열 초기화
FOR i=0 to k do    // C 배열을 0으로 초기화
    C[i] = 0 

// 2. 각 항목의 개수 세기 (1단계)
FOR j=0 to n-1 do
    C[A[j]] = C[A[j]] + 1
// 결과 C: [1, 3, 1, 1, 2]

// 3. 누적 합 계산 (2단계)
FOR i=1 to k do 
    C[i] = C[i] + C[i-1] 
// 결과 C: [1, 4, 5, 6, 8]

// 4. 정렬된 위치에 값 넣기 (3단계)
FOR j=n-1 down to 0 do 
    // C[A[j]] 값은 해당 숫자가 위치할 마지막 자리
    // 인덱스는 0부터 시작하므로 1을 빼준다.
    B[C[A[j]] - 1] = A[j]
    C[A[j]]-- // 다음 동일한 숫자는 바로 앞자리에 위치해야 하므로 1 감소
```