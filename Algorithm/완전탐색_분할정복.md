- [분할 정복](#분할-정복)
  - [하향식 접근 Top-Down](#하향식-접근-top-down)
  - [✏️ 같은 색 공간 만들기 - 백준 색종이 만들기 2630](#️-같은-색-공간-만들기---백준-색종이-만들기-2630)


# 분할 정복 

✅ 정의

큰 문제를 동일한 작은 문제로 쪼갠다 
- 분할: 해결할 문제를 여러 개로 나누고
- 정복: 나눈 작은 문제를 각각 해결하고 
- 통합: 해결된 해답들을 모은다 
- O($\log_{2}{N}$) 

> [!note]
> 💡 예시 문제 
> 
> n개의 동전 중에 가짜 동전이 있다고 하자. 가짜가 조금 더 가볍다. 
> 
> 진짜 동전들은 무게가 다 같다고 하면, 양팔 저울을 최소한으로 사용해서 가짜 동전을 찾는 방법은 무엇일까? 
> 
> - 예를 들어서 24개가 있다고 한다면? (진짜 23개, 가짜 1개) ⇒ 저울 사용횟수: 4번
>     - 16 = 2^4 < 24 < 32 = 2^5 → logN
> - 만약, 양팔저울이 3개가 있으면, 2덩이가 아닌 3덩이로 나눠보자.

## 하향식 접근 Top-Down 
문제의 크기 n >> 크기가 n/2인 부분문제1,2 >> .. >> 각 부분문제의 해 합쳐서 >> 전체 문제의 해 

- 재귀를 사용해서 많이 푼다. 

> [!note]
> 💡 거듭제곱 문제 
> - $C^n$ 
>   - n이 짝수일 때는 $C^{n/2}$ * $C^{n/2}$
>   - n이 홀수일 때는 $C^{n/2}$ * $C^{n/2}$ * C
>
> ✏️ 반복문으로 푼다고 하면? 
> - n이 20억이 되면 풀이가 불가능. 
> 
> ✏️ 분할 정복으로 푼다면? 
> - n이 10억이 되어도, 연산 횟수는 30번으로 줄어든다. 
>
> ---
> 슈도 코드 
> recur_power(x, n)
>   if n == 1: return x
>   if n is EVEN
>       y <- recur_power(x, n/2)
>       return y*y
>   else
>       y <- recur_power(x, (n-1)/2)
>       return y*y*x 

## ✏️ 같은 색 공간 만들기 - 백준 색종이 만들기 2630

💡 문제
- n*n 정사각형 공간에서, 하얀색 공간과 초록색 공간의 정사각형 개수를 구하라. 

📌 규칙 

- N 은 2의 n승 형태를 보인다.
- 공간이 모두 같은 색으로 칠해져 있지 않으면 가로와 세로 중간 부분을 잘라서 똑같은 크기의 4개의 N/2 x N/2 공간으로 나눈다. ⇒ 같은 색이면 분할 안함
- 이렇게 나누어진 공간이 모두 하얀색 또는 초록색 또는, 1x1 공간이 될 때까지 반복한다.

📌 풀이 방식

- 4분할을 한다.
- 동일한 문제인데, 크기만 줄어든 걸로 보고 각 4분할된 영역에 대해 동일하게 처리한다.

⚠️ 기저 조건: 모두 같은 색상이거나 크기가 1인 경우
```java
static void makeSpace(int r, int c, int size) { 
    // 주어진 영역이 모두 같은 색상으로 이루어졌는지 체크 
    int sum = 0; 
    for(int i=r, rEnd=r+size; i<rEnd; i++) {	
        for(int j=c, cEnd=c+size; j<cEnd; j++) {
            sum += spaces[i][j]; 
        }
    }
    // 같은 색으로 이루어져 있다면 해당색의 카운트 증가 후 리턴 
    // white 0 green 1
    if(sum == size*size) { // 모두 초록색이면 
        green++;
    } else if (sum == 0) { // 모두 하얀색이면 
        white++;
    } else { // 섞여 있으면 
        // 같은 색으로 이루어져 있지 않다면 4분할 후 각 공간에 대해 동일한 처리 
        int newSize = size/2; 
        makeSpace(r, c, newSize);			// 좌측상단 영역
        makeSpace(r+newSize, c, newSize);	// 좌측하단 영역 
        makeSpace(r, c+newSize, newSize); 	// 우측상단 영역
        makeSpace(r+newSize, c+newSize, newSize);	
    }	
    }
```