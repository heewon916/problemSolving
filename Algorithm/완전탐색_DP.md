- [DP 동적 계획법](#dp-동적-계획법)
  - [동적 계획법의 적용 요건](#동적-계획법의-적용-요건)
  - [동적 계획법 풀이 과정](#동적-계획법-풀이-과정)
    - [최적의 원칙이 적용되지 않는 예](#최적의-원칙이-적용되지-않는-예)
    - [DP vs. 그리디 vs. 분할정복](#dp-vs-그리디-vs-분할정복)
  - [예시1. 이항 계수 구하기 - 하향식 Top Down](#예시1-이항-계수-구하기---하향식-top-down)
  - [예시2. 동전 거스름 돈 구하기](#예시2-동전-거스름-돈-구하기)
    - [문제](#문제)
    - [생각1. 그리디](#생각1-그리디)
    - [생각2. 재귀로 풀어보기](#생각2-재귀로-풀어보기)
    - [DP접근: 상향식](#dp접근-상향식)
  - [예시3. 미로 이동하기➡️ 백준 11048 이동하기](#예시3-미로-이동하기️-백준-11048-이동하기)

# DP 동적 계획법

그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘

> [!important]
> 하향식 설계 ➡️ 상태공간트리 그려보기 ➡️ 중복 호출 파악 ➡️ 상향식으로 뒤집어서 풀어내기

- 먼저 작은 부분 문제들의 해를 구하고,
- 이들을 이용하여 큰 크기의 부분 문제들을 해결하여,
- 최종적으로 원래 주어진 문제를 해결하는 알고리즘 설계 기법

## 동적 계획법의 적용 요건

1. 중복 부분문제 구조
   - 이전에 계산되었던 작은 문제의 해가, 다른 어딘가에서 필요하게 되는 것
2. 최적 부분문제 구조
   - 문제 A에 대한 해가 최적이면,
   - A의 작은 문제들의 해 역시 최적이어야 한다

## 동적 계획법 풀이 과정

1. 문제에 대한 이해, 정의
   - 최적해, 경우의 수
2. 부분 문제 식별
   - 상태 공간 트리를 적극적으로 활용
3. 동적 테이블을 정의한다.
   - 1차원, 2차원
   - EX) `D[i] = 값`
     1. `i`: 부분 문제의 상태
     2. `값`: 부분 문제를 해결한 값
4. 부분 문제들 간의 관계 파악 후, 점화식 도출
   - `D[i]`, `D[i-1]`, `D[i-2]` .. 어떤 관계인지
   - 관계 수립이 안되는 대상 = **기저 조건**
     - 더 작은 부분문제들을 이용해서, 자신을 정의할 수 없는 경우
5. 동적 테이블 초기화 후, 점화식을 이용해 문제 해 계산
6. 해 도출
   - 항상 마지막에 채워진 값이 해는 아니다.
7. 공간 복잡도의 최적화

### 최적의 원칙이 적용되지 않는 예

최장경로 문제

![alt text](img/image-4.png)

- 최장경로는 ACBD
- 그러나, A-C 사이의 최장경로는 ABC이다.
- 따라서, 전체 해의 작은 부분 문제의 해가 사용되지 않는다

### DP vs. 그리디 vs. 분할정복

> [!note]
> 그리디
>
> - 지금 당장의 최선 ➡️ 전체 최적이 아닐 수 있다. 최적이 보장될 때만 그리디를 쓰자.
>
> ❓그리디가 실패할 수 있다는 걸 의심해봐야 할 때❓
>
> - **현재의 선택이 미래의 선택지에 영향을 미치는가?** ➡️ 현재의 선택으로 인해, 나중에 더 좋았을 수도 있는 선택지가 사라지거나, 가치가 변하면 그리디 안됨
>   - 예시) 여행 경로 문제
> - **하나의 요소에 대한 결정이 독립적인가?** ➡️ 여러 요소 간의 결합으로 전체 결과가 달라진다면 그리디 안됨
>   - 예시) 0/1 배낭 문제, 감시 문제
>
> 요약
>
> 1. 가장 먼저 드는 그리디한 해법을 떠올린다. (예: cctv는 무조건 가장 많이 볼 수 있는 방향으로 돌리자)
> 2. 그 해법을 무너뜨릴 수 있는 간단한 반례 떠올리기. (예: cctv 2대가 거의 같은 영역을 볼 때, 한 대가 욕심부리면 다른 한 대는 거의 쓸모 없어지는 상황을 만들 수 있지 않을까?)
> 3. 반례가 쉽게 찾아진다면 그 문제는 모든 경우를 탐색해야 하는 dfs/bfs, 백트래킹, DP문제일 확률이 높다.

- 분할정복은 연관 없는 부분 문제들로 나뉜다.
- DP는 부분문제들이 연관이 있다.

---

## 예시1. 이항 계수 구하기 - 하향식 Top Down

이항계수를 `nCk`를 구하는 재귀함수

- 계산량이 많은 `n!` 또는 `k!`를 계산하지 않고 `n-1Ck-1 + n-1Ck` 를 사용한다.
  - n번째 수를 선택한 경우: `n-1Ck-1`
  - n번째 수를 선택하지 않은 경우 `n-1Ck`

![alt text](img/image-5.png)

```java
// O(nk)

B[][] // 동적테이블
FOR i in 0..n
    FOR j in 0..min(i, k)
        IF j==0 OR j==i
            B[i][j] = 0
        ELSE
            B[i][j] = B[i-1][j-1] + B[i-1][j]

RETURN B[n][k]
```

---

## 예시2. 동전 거스름 돈 구하기

### 문제

- N원을 1원, 4원, 6원을 사용해서 8원을 거슬러줄 때, 사용할 최소 동전의 개수

### 생각1. 그리디

큰 액수부터 고른다.

- 6+1+1
- 그러나, 4+4가 더 최적이다.
- 그리디가 통하지 않는다.

### 생각2. 재귀로 풀어보기

- 1원 + **7원에 대한 최적해**
  - 7원에 대한 최적해:
  - 1원 + **6원에 대한 최적해**
    - ...반복
  - 4원 + **3원에 대한 최적해**
  - 6원 + **1원에 대한 최적해**
- 4원 + **4원에 대한 최적해**
- 6원 + **2원에 대한 최적해**

➡️ 중복으로 계산해야 하는 부분들이 많아보인다. => 중복 부분문제 구조

➡️ 더 작은 부분문제의 해가 최적이면, 더 큰 정답도 최적이다 => 최적 부분 구조

➡️ DP로 풀자!

### DP접근: 상향식

- 1원 최적해 -> 2원 최적해 -> .. -> N원에 대한 최적해
- `C[n] = n원을 거슬러 줄 때의 최소 동전 수`
- 점화식: `C[n] = MIN(n>=1이면 C[n-1]+1, n>=4이면 C[n-4]+1, n>=6이면 C[n-6]+1)`

![alt text](img/image-27.png)

---

## 예시3. 미로 이동하기➡️ 백준 11048 이동하기

문제

- NxM 배열에서, 오른쪽/ 아래/ 대각선 오른쪽 아래로만 이동 가능하다.
- 이때, 각 칸에는 자연수가 적혀있다.
- (0,0)에서 (N,M)으로 갈 때 수들의 합이 최대가 되는 경우, 그 합은?

점화식

- `D[N+1][L+1]`
  - 패딩을 주자. `i==0`이거나 `j==0`인 경우에는 나에게 오는 3방향이 모두 기존 배열 안에 없기 떄문이다.
- `D[N][M] = (1,1)에서 (N,M)까지 도달했을 경우 최대로 획득가능한 선물 개수`
- `D[N][M] = max(D[N-1][M], D[N-1][M], D[N][M-1])`
