# 완전탐색

완전탐색(Brute Force)의 전형적인 핵심 도구

1. 순열 Permutation: 순서 따지고, 중복 없음
2. 조합 Combination: 순서는 안 따지고, 중복 없음
3. 부분집합 Subset: 어떤 원소를 포함하거나 미포함하면서 부분수열이 만들어짐

## 순열

N개의 수 중에서, R개를 뽑아 순열을 만들 때

- 순서를 따지고,
- 중복해서 뽑기 불가능이면

기본 코드 - 백트래킹

- 방문 처리 배열 v
  - 중복을 방지하기 위해 필요하다
- `cnt`<- depth
  - 지금까지 몇 개의 원소를 선택했는가
  - `b[cnt]`와 같이 결과 저장 배열의 인덱스 역할도 한다.

```java
public class PermMain {
	static int N = 4, R = 3, C = 0;
	static int[] a = {1,2,3,4}, b=new int[R]; // 4개 중에서 B 배열에 R개 만큼 채워넣는다.
	static boolean[] v = new boolean[N];

	static void perm(int cnt) {
		if(cnt == R) {
			System.out.println(Arrays.toString(b));  C++;
			return;
		}
		for(int i=0; i<N; i++) {
			if(v[i]) continue;
			v[i] = true; 		// 아직 사용하지 않은 수 방문 처리
			b[cnt] = a[i];		// 순열에 포함시키고
			perm(cnt+1);		// 다음 수를 고르러 갔다가
			v[i] = false; 		// ⭐돌아오면 false로 바꿔줘야 한다.
		}
	}
	public static void main(String[] args) throws Exception{
		// TODO Auto-generated method stub
		C = 0;
		perm(0);
		System.out.println(C);
	}
}
```

## 조합

N개의 수 중에서, R개를 뽑아 순열을 만들 때

- 순서를 따지지 않고,
- 중복해서 뽑아도 된다면

기본 코드: 백트래킹

- `cnt`
  - 현재까지 선택한 원소 개수
  - `b[cnt]`: 저장 배열의 인덱스 역할도 한다.
- `start`
  - 다음 반복을 어디서부터 시작할까?
  - **중복 방지이면** -> i+1부터
  - **중복 허용이면** -> i부터 (방금 뽑은데도 다시 포함시키기)

```java
public class CombMain {
	static int N = 4, R = 3, C = 0;
	static int[] a = {1,2,3,4}, b=new int[R]; // 4개 중에서 배열b에 R개 만큼 채워넣는다.
	/*
	 * cnt: depth이자, b배열의 인덱스이자, nCr에서 몇 개를 선택한 상태인가
	 */
	static void comb(int cnt, int start) {
		if(cnt == R) {
			System.out.println(Arrays.toString(b));  C++;
			return;
		}
		for(int i=start; i<N; i++) {
			b[cnt] = a[i];

			// comb(cnt+1, i+1); 		// 조합: 1을 더하면 다음 숫자부터 보기에 중복이 알아서 제거된다.
			comb(cnt+1, i); 			// 중복 조합: 현재 인덱스를 한 번 더 사용하면 된다.
		}


	}
	public static void main(String[] args) throws Exception{
		C = 0;
		comb(0, 0);
		System.out.println(C);
	}
}
```

### 조합의 응용: R 값이 변한다면?

- 즉, **부분집합을 조합으로도 구현할 수 있다**. 단지, 부분집합으로 구현하는 것보다 시간이 좀 더 걸린다.

#### 💡응용코드1.

- `cnt`
  - 현재 몇 개를 선택했는지 체크 => depth에 도달하면 멈춘다.
- `start`
  - 다음 반복을 어디서 시작할지 나타낸다.
  - 보통 조합이면 중복으로 뽑으면 안되기 때문에 i+1이 된다.
- `depth`
  - 기저 조건이 된다.
  - N개 중에 R개를 뽑아야.. 에서 R개를 담당한다.

```java
for(int i=1; i<N+1; i++) {
	b = new int[i];
	comb(0, 0, 0, i);
}
...
static int[] b;
static void comb(int cnt, int start, int sum, int depth) {
	if(cnt == depth) {
		if(sum == S) {
//			System.out.println(Arrays.toString(b));
			res_cnt++;
		}
		return;
	}
	for(int i=start; i<N; i++) {
		b[cnt] = arr[i];
		comb(cnt+1, i+1, sum+arr[i], depth);
	}
}
```

#### 💡응용코드2. cnt의 사용에 주의하자 (feat. bj 17471 게리맨더링)

- `cnt`는 몇 개를 골랐냐를 의미한다.
- 때로는 배열 b의 크기를 N으로 만들어 **마스킹처럼 사용**해야 할때가 있다.
- 이 경우에는 인덱스로 `cnt`가 아닌, for문의 `i`를 사용해야 한다.

```java
// comb의 내부 코드
if(cnt == depth) {
	...
}
for(int i=start; i<N+1; i++) {	// 조합의 핵심: 백트래킹
//	b[cnt] = 1; 				// 몇 개 골랐냐가 아니라, 어느 위치를 골랐냐가 중요함
	b[i] = 1; 					// i 위치에 1을 넣고
	comb(cnt+1, i+1, depth);	// 조합 만든 뒤
	able = true;
	b[i] = 0; 					// 다시 복구
}
```

> 💡 관련 문제
>
> - 백준 1182. 부분수열의 합
> - 백준 17471. 게리맨더링

## 부분집합
- 어떤 원소를 포함하거나 미포함하면서 부분수열이 만들어짐
- 보통 백트래킹으로 구현된다.

### 부분집합 기본코드
```java
/**
 * 부분집합 
 * {1,2,3,4}에 대한 부분집합을 만든다. 
 * 총 2^4 = 16가짓수가 나온다. 
 * 그 결과를 비트 연산으로 생각하면 easy
 */
public class SubsMain {
	static int N = 4, C = 0; 
	static int[] a = {1,2,3,4} ;
	static void subs(int cnt, String str) { 
 
		if(cnt == N) {
			System.out.println(str);  C++;
			return;
		}
		// ✅ 핵심코드 
		subs(cnt+1, str+"-");
		subs(cnt+1, str+a[cnt]);
	
		
	}
	public static void main(String[] args) throws Exception{
		C = 0; 
		subs(0, "");
		System.out.println(C);
	}
}

```