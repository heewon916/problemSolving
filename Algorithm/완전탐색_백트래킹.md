- [백트래킹](#백트래킹)
  - [백트래킹을 이용한 알고리즘의 절차](#백트래킹을-이용한-알고리즘의-절차)
  - [백트래킹과 완전탐색에서 DFS의 차이점](#백트래킹과-완전탐색에서-dfs의-차이점)
  - [부분집합의 합 문제 - 자연수냐, 정수냐](#부분집합의-합-문제---자연수냐-정수냐)

# 백트래킹

**✅ 정의**

완전탐색 + 가지치기

- 모든 가능성은 하나의 트리처럼 구성할 수 있고, 그 가지 중 해결책이 있다.
- 모든 가능한 경우의 수 중에서 특정한 조건을 만족하는 경우만 살펴본다.
- DFS로 모든 경우의 수를 탐색하다가, 답이 절대 될 수 없는 상황을 정의해 가지치기 한다.

> [!note]
> ✏️ N-Queen 문제
>
> - NxN 장기판에서, N개의 Queen이 서로를 위협하지 않게 배치할 수 있는 경우의 문제
> - ➡️ 이 문제는 상태공간트리로 연상하고, 결국 트리 탐색 문제라는 것을 알아내는 것이 중요하다.
>
> 💡 4-Queen 문제로 축소하고 같은 행에 퀸을 두지 않는 방법으로 제한둬서 생각해보기
>
> - (1,1)에 두었을 때 루프 (2,1), (2,2), (2,3), (2,4) 중 어디에 둘 수 있는지 .. 반복
> - 루프 -> 리프로 가면서 "경로"를 본다.
> - ➡️ 선택들의 집합을 보는 것
> - ➡️ 결국 트리탐색 문제로 간다.
>   - 루프 노드에서 리프 노드까지 경로를 하나 깊이 탐색하므로, 통상 DFS로 풀이하는 것이 좋다.

## 백트래킹을 이용한 알고리즘의 절차

1. 상태 공간 트리의 깊이 우선 검색 DFS 실시
2. 각 노드가 유망한지 검사
3. 유망하지 않으면 부모 노드로 돌아가, 다른 자식 노드의 검색을 계속한다

## 백트래킹과 완전탐색에서 DFS의 차이점

**💡완전탐색**

- 모든 경로를 추적하고, **해결책으로 이어지지 않더라도 탐색**한다.

**💡백트래킹 ← DFS의 응용 버전(깊이 우선 탐색 + 가지치기)**

- 해결책으로 이어질 것 같지 않은 경로는 가지 치기로 더 이상 따라가지 않는다. **pruning**
- 백트래킹 알고리즘을 적용하면 경우의 수는 줄어들지만,
  ⚠️**최악의 경우 결국 지수함수 시간을 요함.**
  => 예를 들어서, 한쪽으로만 계속 파고 들어야 할 때

➡️ 가지치기 조건을 잘 찾아내야 한다. (기저조건)

## 부분집합의 합 문제 - 자연수냐, 정수냐

> [!note]
> 문제
>
> - N개의 **정수**로 이루어진 집합
> - 부분집합 중에서, 원소의 합이 0이 되는 경우의 수는?
>
> 💡완전탐색으로 풀 때
>
> - 모든 부분집합을 생성한 뒤, 각 부분집합의 합 계산하기
> - 시간복잡도: O($n*2^n$)
>
> 💡백트래킹으로 풀 때
>
> - running sum을 유지하면 O($2^n$)
>
> ---

슈도 코드: 백트래킹

```java
static int N, ans;
static int[] a;
static void dfs(int idx, int sum){
     if(idx == N){
         if(sum == 0) ans++;
         return;
     }
     dfs(idx+1, sum);         // a[idx] 미포함
     dfs(idx+1, sum + a[idx]);// a[idx] 포함
 }
```

> [!warning]
> 문제
>
> - N개의 **자연수**로 이루어진 집합
> - 부분집합 중에서, 원소의 합이 K가 되는 경우의 수는?
>
> **⚠️주의사항**
>
> - 정수일 때는 합이 항상 커지지 않으므로, `if(sum > K) return`처럼 가지치기하면 안된다.
> - 자연수일 때는 목표합이 넘어버리면 가지치기로 그 뒤의 상황을 보지 않아도 된다.

슈도 코드: 백트래킹 + 가지치기

- 자연수이므로, 배열`a`를 오름차순 정렬하자. 그러면 가지치기 효과가 높아진다.

```java
static int N;
static long K;
static int[] a;
static long ans;

static void dfs(int idx, long sum) {
    if (sum > K) return;      // 자연수 전제 → 초과 시 더 진행해도 모두 초과
    if (sum == K) {           // 목표 달성 → 이후 원소를 더하면 반드시 초과
        ans++;
        return;
    }
    if (idx == N) return;     // 더 선택할 원소 없음

    // 미포함
    dfs(idx + 1, sum);

    // 포함
    dfs(idx + 1, sum + a[idx]);
}
```
