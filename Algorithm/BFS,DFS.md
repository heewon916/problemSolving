# 💡 탐색 
- 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정. 
- 그래프, 트리 등의 자료구조 안에서 탐색을 주로 한다. 

# 💡 깊이우선탐색 DFS
- 반복문, 재귀함수를 통해 구현된다. 
- 깊이를 우선으로 탐색한다. 
### 알고리즘 진행방식
1. 현재 노드를 방문한 것으로 표시한다. 
2. 현재 노드의 인접 노드 중에서 
   3. 아직 방문하지 않은 노드에 대해 탐색한다. 
   4. 더 이상 방문하지 않은 정점이 없으면 이전 정점으로 백 트래킹한다. 
5. 모든 정점을 방문할 대까지 1-4번을 반복한다. 
### 기본 코드 
```python
visited = [0] * (N+1)
def dfs(v):
    global visited
    visited[v] = 1
    print(v, end=' ')
    for z in graph[v]:
        if not visited[z]:
            dfs(z)
```
# 💡 너비우선탐색 BFS
- Queue를 사용한다. 
- 가까운 노드부터 탐색한다. 
- 메모리를 많이 쓰는 대신, DFS보다 빠르다. 
### 알고리즘 진행방식
1. 탐색 시작 노드를 큐에 삽입하고 방문 처리를 한다. 
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 
   3. 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 한다. 
4. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다. 
### 기본 구현 코드 
```python
def bfs(v):
    visited = [0] * (N + 1)
    q = [v]
    visited[v] = 1
    while q:
        x = q.pop(0)
        # visited[x] = 1 # 노드를 꺼낼 때 처리하면 같은 노드가 중복해서 큐에 들어갈 수 있음.
        print(x, end=' ')
        for z in graph[x]:
            if not visited[z]:
                q.append(z)
                visited[z] = 1
```

# 📌 DFS가 유리한 경우 
- 재귀적인 특징과 백트래킹을 이용해 모든 경우를 하나씩 전부 탐색하는 경우 
- 그래프의 크기가 클 경우 
- 최적화된 답을 찾는 것이 아닐 경우 
- 경로의 특징을 저장해야 하는 경우 ex. 경로의 가중치


# 📌 BFS가 유리한 경우 
- 최단 거리 or 최단 횟수 구하는 경우 
- 최적화된 답을 찾는 경우 => BFS는 가장 처음 발견되는 해답이 최단 거리이다. 
- 탐색의 횟수를 구해야 하는 경우


# ⭐ 길찾기 문제 = DFS/BFS 단골 문제 
1. dx, dy, (dz)를 정의한다. (상하좌우 움직이는 거 계산 가능함) 
2. visited = [[0] * N for _ in range(N)] 방문한 곳은 체크표시한다. 
3. for문으로 nx, ny = x + dx[i], y + dy[i] 를 계산해 (1) 범위 내인지 (2) 방문 안한곳인지 체크하면 된다. 


# 📌 백트래킹
- 기본적으로 완전 탐색 알고리즘이다. 
- DFS나 BFS와 같은 방식으로 진행되지만, 
- 진행 과정에서 답이 아닌 분기를 만나면 탐색을 진행하지 않고 돌아가 다른 분기로 감으로써 가지치기를 한다. 
=> 결론: DFS, BFS 풀 때 if (): return 이럴 때가 백트래킹에 해당한다고 보면 됨. 
