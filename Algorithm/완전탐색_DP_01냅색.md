# 0-1 냅색

## 냅색 문제의 정형적 정의 

- N개의 물건들의 집합이 있을 때, 
- 각 물건들은 $w_i$의 무게와, $v_i$의 가치를 갖는다. 
- 이때 가방이 수용할 수 있는 무게는 `W`이다. 
- 물건들의 부분집합 중, 그 무게의 총합이 `W`를 안 넘으면서, 가치의 합이 최대가 되도록하는 부분집합을 구하게 한다. 

### 냅색 문제의 유형 
1. 0-1 냅색 
    - 배낭에 물건을 쪼개지 않고 통째로 담아야 할 때 
2. fractional 냅색 
    - 물건을 쪼개서 담을 수 있는 경우

## 0-1 냅색 문제의 사고 과정

![alt text](img/image-25.png)

**[탐욕]** 
- 완전탐색으로 부분집합을 모두 구하고, 부분집합의 총 무게가 W를 초과하면 버린다. ➡️ 시간복잡도: O($2^n$)
- n = 20이면 100만번, n = 30이면 10억번의 연산을 해야 하므로 n의 값이 중요해진다. 


**[0-1냅색]** 

![alt text](img/image-26.png)

  - 상태공간트리를 그려본 결과 최적부분문제구조와 중복부분문제구조를 모두 만족함을 알 수 있다. 
  - 따라서 `DP`로 접근해본다. 
  - 부분문제를 찾기 위해 필요한 문제의 조건을 살펴본다. 
    - 물건 
    - 물건의 무게 
    - 물건의 가치 
    - 배낭의 용량 
  - 물건, 물건의 무게는 부분문제를 정의하는데 반드시 필요하다 

DP로 풀 수 있다는 것을 알게 되었으니, 기저 조건을 찾아야 한다. 
- 물건 i까지 고려한다고 가정하자. 
- 그때 `W`의 무게를 넘지 않으면서 
- 각 물건을 자신의 무게만큼의 가방에 담는다고 생각해본다. 

## 0-1 냅색 문제의 부분문제 정의

**CASE 1: K[i-1, w]**

- 최적해는 물건 i를 포함하지 않는다고 가정할 때 


**CASE 2: K[i-1, w-$w_i$]** 

- 최적해는 물건 i를 포함한다고 가정할 때
- **전체 가치 = 물건 i의 가치 $v_i$ + 물건 1~(i-1)까지 고려하면서 배낭의 용량이 $w-w_i$인 경우의 최대 가치**


즉, CASE1 과 CASE 2가 미리 계산되어 있어야만 K[i,w]를 계산할 수 있다. 


![alt text](img/img_0-1냅색_2.jpg)


## 0-1 냅색 문제의 sudo code 
```java
// 배낭의 용량 W 
// n개의 물건과, 각 물건 i의 무게 wi와 가치 vi 
// 단, i=1,2,3...n/ w=1,2,3..W 
// int[][] K = new int[n+1][W+1]

FOR i in 0->n: K[i,0] = 0
FOR w in 0->W: K[0,w] = 0

FOR i in 1..n
    FOR w in 1..W
        IF w_i > w  // 물건 i를 포함할 수 없는 경우 이전의 최대가치를 가져온다. 
            K[i,w] <- K[i-1, w]
        ELSE        // 물건 i를 포함할 수 있는 경우, w-w_i에 대한 이전의 최대가치를 가져온다. 
            K[i,w] <- max(v_i + K[i-1, w-w_i], K[i-1, w])
```

## 0-1 냅색 문제의 수행과정 

시간복잡도: O($N*W$)

1. 배낭을 초기화한다.  
    - i=0이거나 w=0인 경우, 최대가치는 0이므로 이들을 초기화한다. 
2. 물건 i까지 차례대로 고려하며, w가 증가할 때 가질 수 있는 최대가치를 계산한다. 
3. 물건 n까지 모두 고려한 뒤, 얻을 수 있는 최대 가치는 `K[n+1][W+1]`이 된다. 


**수행과정:**

![alt text](img/img_0-1냅색_3.jpg)

**최종 결과:**

![alt text](img/img_0-1냅색_4.png)

# 냅색의 공간복잡도를 개선

## 2차원 배열을 1차원 배열로 압축한다 + 역순 탐색이 동반되어야 한다 

테이블 정의 `K[W]`

- 현재까지 고려한 물건들로, 용량 w를 채울 때 얻을 수 있는 최대 가치 
- 물건 i를 고려하고 있다면, 테이블에는 물건 i-1에 대해서 용량 w를 채울 때 얻을 수 있는 최대 가치들이 저장되어 있다. 
- 초기값: 모두 0이다. 

점화식

- 물건 i에 대해 최대 가치를 계산하는 과정이라고 한다면,
  ```java
  FOR w in n->1
    K[w] = max(K[w], K[w-w_i] + v_i) 
  ``` 
- 역순 탐색해야 하는 이유
  - 순방향 탐색할 경우, 앞서서 이미 사용한 물건을 또 사용하는 문제가 발생한다. 

![alt text](<img/Screenshot_20250908_154619_Samsung Notes.jpg>)
![alt text](<img/Screenshot_20250908_154635_Samsung Notes.jpg>)

## 문제의 변형 
- 물건을 여러 개 담는 것이 가능하다면?
- 물건의 개수가 무제한이 되었다.

➡️ i번째 물건까지 고려하게 되었을 때, K[i, w-w_i]+v_i까지 고려해야 한다.

➡️ 하나의 테이블을 반복적으로 채우는 방향으로 갈 수 있다

➡️ 물건 i를 보고 있다고 할 때 `k[w] = k[w-w_i] + v_i(나를 넣는 경우) + k[w](나를 안 넣는 경우)`

➡️ 업데이트 전이므로 i-1의 상태를 기준으로 1차원 배열이 채워져 있고, 거기에 나를 추가할래 말래로 나누어진다.

