# 📌 탐욕 알고리즘 
- Greedy: 탐욕스러운, 욕심 많은 
> **선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달하는 것**이다. 
>  - 순간마다 하는 선택은 그 순간에 대해 지역적으로 최적이다. 
>  - 하지만, 그 선택을 계속 수집해 최종(전역) 해답을 얻었을 때는, 그것이 최적이라는 보장이 없다.

## 탐욕 알고리즘 해결 방법 
1. 현재 상태에서 최적의 해답을 선택한다.
2. 선택된 해가 문제의 조건을 만족하는지 검사한다. 
3. 원래의 문제가 해결되었는지 확인하고, 해결되지 않으면 선택 절차로 돌아간다. 

## 탐욕A 적용하기 위한 문제의 조건 
1. 앞의 선택이 이후의 선택에 영향 안 줌 
2. 문제에 대한 최적해가 부분문제에 대해서도 역시 최적해임 

## 매트로이드 
- 어떤 특별한 구조가 있는 문제로, 탐욕 알고리즘이 언제나 최적해를 찾아낼 수 있다. 
- 동전의 개수 헤아리기(최소 개수 거스름돈)
- ‼️예외) 도둑 문제 
  - 35kg의 가방에 최대 가치로 물건을 훔칠 때, 그림(100, 30kg)/ 컴퓨터(80, 20kg)/반지(30, 5kg) 3개가 있다고 하자. 최대 가치 순으로 하면 그림만 담을 수밖에 없다. 탐욕A가 아닌 경우에는, 컴퓨터+반지로 더 많은 가치의 물건을 훔칠 수 있다. 

## 정리 
> 탐욕 알고리즘은 문제를 해결하는 과정에서 매 순간, 최적이라 생각되는 해답(locally optimal solution)을 찾으며, 이를 토대로 최종 문제의 해답(globally optimal solution)에 도달하는 문제 해결 방식이다.
> 그러나 도둑의 예와 같이 항상 최적의 결과를 보장하지는 못한다는 점을 명심해야 한다. 
> 따라서 두 가지의 조건을 만족하는 “특정한 상황” 이 아니면 탐욕 알고리즘은 최적의 해를 보장하지 못한다.

# 📌 동적 계획법 (DP: Dynamic Programming)  

작은 문제들을 풀면서 그 결과를 저장해 나아가면서 전체 문제를 해결하는 알고리즘
일반적으로 재귀적으로 구현되며 **메모이제이션(Memoization) 기법**을 사용하여 중복 계산을 피한다.

## 📎DP 푸는 방법 1

1. 문제를 하위 문제로 쪼갠다.
2. 하위 문제를 재귀적으로 해결한다.
3. 결과를 저장한다. (메모이제이션)
4. 저장된 결과를 이용하여 큰 문제를 해결한다.

## 📎DP 푸는 방법 2

1. 문제의 조건대로 **손으로 그려보며 반복되는 부분을 찾**는다.
2. dp테이블 dp[i]는 무엇을 의미하는지 정의해본다.`dp[i] = ???`
3. **디테일한 점화식**을 세운다.`dp[i] = dp[i-1] + dp[i-2]`
   - 필요하다면 dp 테이블을 확장.`dp[i] → dp[i][j]`
4. 어떤 방법으로도 점화식 세워지지 않으면 계산 과정이나 정의의 순서를 뒤집어서 생각해본다. 
   - 예를 들면 계산 과정을 완전히 거꾸로 뒤집어보는 발상. 즉 1+1=2 이 아니라 2=1+1 이라는 발상을 하는 것.
5. 1번으로 되돌아가서 다시 진행합니다.

## 📢 동적 계획법을 사용하려면 다음의 조건을 만족해야 한다.

1. 최적 부분 구조 (Optimal Substructure)
**'큰 문제의 최적해'가 '작은 문제의 최적해'를 포함**하는 성질. 
즉, 작은 문제의 최적해를 구한 후 그것을 이용하여 큰 문제의 최적해를 구할 수 있다.

2. 중복 부분 문제 (Overlapping Subproblems)
**'동일한 작은 문제를 반복적으로 해결'해야** 하는 성질. 
즉, 작은 문제를 해결할 때 반복적으로 같은 문제를 해결해야 한다.


## 📢 동적 계획법 푸는 방식 2가지 
1. **탑다운(Top-Down) 방식**
- 재귀적으로 호출해 문제를 해결한다. 
- 현재 밟고 있는 칸까지 어떻게 왔는지 경우 가짓수
- 분할정복 방식과 비슷함. 
- 단, 중복되는 작은 문제들은 한번만 푼다. 
- 문제점: 스택 오버플로가 발생할 수 있다.

2. **바텀업(Bottom-Up) 방식**
- 작은 문제 ==> 큰 문제까지 해결 
- 현재 밟고 있는 칸에서 뻗어갈 수 있는 칸의 경우 가짓수
- 이전에 계산한 부분의 결과는 저장해둔다 -> 나중에 같은 부분문제 나타날 때 저장된 값을 사용한다.
- 재귀 수행 X 반복문 수행 
