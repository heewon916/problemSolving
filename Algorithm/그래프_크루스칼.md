# ëª©ì°¨

- [ëª©ì°¨](#ëª©ì°¨)
- [í¬ë£¨ìŠ¤ì¹¼ vs. í”„ë¦¼ vs. ë‹¤ìµìŠ¤íŠ¸ë¼](#í¬ë£¨ìŠ¤ì¹¼-vs-í”„ë¦¼-vs-ë‹¤ìµìŠ¤íŠ¸ë¼)
- [í¬ë£¨ìŠ¤ì¹¼](#í¬ë£¨ìŠ¤ì¹¼)
	- [ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬](#ìµœì†Œ-ì‹ ì¥-íŠ¸ë¦¬)
	- [ì‹ ì¥ íŠ¸ë¦¬](#ì‹ ì¥-íŠ¸ë¦¬)
- [í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ ~ ê°„ì„  ì¤‘ì‹¬](#í¬ë£¨ìŠ¤ì¹¼-ì•Œê³ ë¦¬ì¦˜--ê°„ì„ -ì¤‘ì‹¬)
		- [ğŸ“Œ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜](#-í¬ë£¨ìŠ¤ì¹¼-ì•Œê³ ë¦¬ì¦˜)

# í¬ë£¨ìŠ¤ì¹¼ vs. í”„ë¦¼ vs. ë‹¤ìµìŠ¤íŠ¸ë¼

> [!important]
> ê·¸ë˜í”„ â†’ V, E
>
> âœ… ìµœì†Œ ì‹ ì¥íŠ¸ë¦¬ë¥¼ êµ¬í•˜ëŠ”ë° (**íŠ¸ë¦¬ ì „ì²´ ê¸°ì¤€ìœ¼ë¡œ** ìµœì†Œ ë¹„ìš©ì˜ ì¸ì ‘í•œ ê°„ì„ ì„ íƒí•œë‹¤)
>
> - ì •ì  ì¤‘ì‹¬ìœ¼ë¡œ í’€ì–´ê°€ëŠ” ì•Œê³ ë¦¬ì¦˜ â‡’ ğŸ“Œí”„ë¦¼
>   - ëª¨ë“  ì •ì ì„ í¬í•¨í•˜ëŠ” ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST)
>   - ì—°ê²°ë¦¬ìŠ¤íŠ¸ + PQ : `O(E logV)`
>   - ì—°ê²°ë¦¬ìŠ¤íŠ¸ë§Œ ì‚¬ìš©: `O(V^2)`
> - ê°„ì„  ì¤‘ì‹¬ìœ¼ë¡œ í’€ì–´ê°€ëŠ” ì•Œê³ ë¦¬ì¦˜ â‡’ ğŸ“Œí¬ë£¨ìŠ¤ì¹¼
>   - ê°„ì„ ë¦¬ìŠ¤íŠ¸ + union-find: `O(E log E)`
>
> âœ… ì‹œì‘ ì •ì  **start ê¸°ì¤€ìœ¼ë¡œ** ëª¨ë“  ì •ì ì— ê°ˆ ìˆ˜ ìˆëŠ” ìµœì†Œë¹„ìš© ê²½ë¡œ êµ¬í•˜ê¸°
>
> - ğŸ“Œë‹¤ìµìŠ¤íŠ¸ë¼
>   - ëª©í‘œ: ì¶œë°œ ì •ì  â†’ ëª¨ë“  ì •ì  ìµœë‹¨ ê±°ë¦¬

# í¬ë£¨ìŠ¤ì¹¼

## ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬

ê·¸ë˜í”„ì—ì„œ ìµœì†Œ ë¹„ìš© ë¬¸ì œë¥¼ í•´ê²°í•œë‹¤

- **ëª¨ë“  ì •ì ì„ ì—°ê²°í•˜ëŠ” + ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œê°€ ë˜ëŠ” íŠ¸ë¦¬**
- ë‘ ì •ì  ì‚¬ì´ì˜ ìµœì†Œ ë¹„ìš© ê²½ë¡œ ì°¾ê¸°
  - ê°€ì¤‘ì¹˜ê°€ 1ê°€ì§€(ëª¨ë‘ ë™ì¼í•œ ê°’) : BFS
  - **ê°€ì¤‘ì¹˜ê°€ 2ê°€ì§€ ì´ìƒì¸ ê²½ìš°: BFSëŠ” ë¹„íš¨ìœ¨ì **
    â‡’ ì˜ ì•Œë ¤ì§„ ìµœë‹¨ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜ - ë‹¤ìµìŠ¤íŠ¸ë¼ - ë²¨ë§Œí¬ë“œ - í”Œë¡œì´ë“œ ì›Œìƒ¬

## ì‹ ì¥ íŠ¸ë¦¬

- nê°œì˜ ì •ì ìœ¼ë¡œ ì´ë£¨ì–´ì§„ **ë¬´í–¥** ê·¸ë˜í”„ì—ì„œ **nê°œì˜ ì •ì  + n-1ê°œì˜ ê°„ì„ **ìœ¼ë¡œ ì´ë£¨ì–´ì§„ íŠ¸ë¦¬
  > **â“ì™œ ëª¨ë“  ì •ì  ìŒì˜ ê²½ë¡œê°€ ì¡´ì¬í•œë‹¤ëŠ” ê²Œ ë³´ì¥ë ê¹Œ?**
  >
  > - íŠ¸ë¦¬ íŠ¹ì„± ìƒ, ì¡°ìƒ ë…¸ë“œë¥¼ ê³„ì† íƒ€ê³  ì˜¬ë¼ê°€ë‹¤ ë³´ë©´, ê²°êµ­ ì–´ë–¤ ì •ì ì´ë“  ë°©ë¬¸í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.
  > - ê·¸ë˜í”„ O(V, E) â‡’ íŠ¸ë¦¬ O(V, V-1)

ì´ëŸ¬í•œ ì‹ ì¥íŠ¸ë¦¬ ì¤‘ì—ì„œë„ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œê°€ ë˜ëŠ” íŠ¸ë¦¬ë¥¼ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¼ê³  í•œë‹¤.

> **â“ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ ì™„íƒìœ¼ë¡œ í•˜ê²Œ ëœë‹¤ë©´?**
>
> ì¦‰, ì‹ ì¥íŠ¸ë¦¬ 1, 2,,â€¦ ì—¬ëŸ¬ ê°€ì§€ë¥¼ ë§Œë“¤ì–´ë³´ê³ , ê·¸ ì¤‘ì—ì„œ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œì¸ íŠ¸ë¦¬ë¥¼ ê°–ëŠ” ê±´?
>
> - vê°œì˜ ì •ì . eê°œì˜ ê°„ì„ ì´ ìˆë‹¤ê³  í•  ë•Œ eê°œì˜ ê°„ì„  ì¤‘ì—ì„œ v-1ê°œì˜ ê°„ì„ ì„ ì„ íƒí•´ì•¼ í•œë‹¤.
> - `eCv-1`ë²ˆì˜ ì—°ì‚° â‡’ ì‹ ì¥íŠ¸ë¦¬ê°€ ê°€ëŠ¥í•˜ë‹¤ë©´ â‡’ ìµœì†Ÿê°’ ì—…ë°ì´íŠ¸
> - `30C15` â†’ 1ì–µ 5ì²œë§Œë²ˆì˜ ì—°ì‚°ì„ í•´ì•¼ í•œë‹¤.
> - ë”°ë¼ì„œ ì´ëŸ° ì—°ì‚° ë°©ë²•ì€ ì–´ë µë‹¤.

# í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ ~ ê°„ì„  ì¤‘ì‹¬

> [!note]
> â“ eC(v-1)ì—ì„œ ì¡°í•©CëŠ” ìƒê°í•˜ì§€ ì•Šê³ , ì„ íƒ ëŠë‚Œì€ ì‚´ë ¤ êµ¬í•œë‹¤ë©´ ì–´ë–»ê²Œ ê°€ëŠ¥í• ê¹Œ?
>
> â†’ ê·¸ë¦¬ë””, Greedyë¡œ í’€ì–´ë‚¼ ìˆ˜ ìˆë‹¤.
>
> â†’ ì „ì²´ Eê°œì˜ ê°„ì„  ì¤‘ì—ì„œ **ìµœì ì˜ 1ê°œì˜ ê°„ì„ **ì„ ì„ íƒí•˜ë©´ ë‚¨ì€ ê°„ì„ ì˜ ê°œìˆ˜ëŠ” E-1ê°œì´ë‹¤.
>
> â†’ ë‚¨ì•„ìˆëŠ” ê²ƒë“¤ ì¤‘ì—ì„œ **ìµœì ì˜ 1ê°œì˜ ê°„ì„ **ì„ ì„ íƒí•˜ë©´, ë‚¨ëŠ” ê°„ì„ ì˜ ê°œìˆ˜ëŠ” E-2ê°œê°€ ëœë‹¤.
>
> â†’ ì´ë ‡ê²Œ **ê°„ì„ ì„ V-1ê°œ ì„ íƒ**í•˜ë©´ ëì´ë‹¤.
>
> â“ì´ê²Œ ìµœì†Œë¹„ìš©ì´ ë³´ì¥ë˜ë ¤ë©´?
>
> â‡’ âœ… **ì „ì²˜ë¦¬: ê°„ì„  ë¦¬ìŠ¤íŠ¸ ê°€ì¤‘ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬í•´ë‘ë©´ ëœë‹¤.**
>
> â“ì—¬ê¸°ì„œ ì‹ ì¥ íŠ¸ë¦¬ë¼ëŠ” ì¡°ê±´ê¹Œì§€ ë§Œì¡±í•˜ë ¤ë©´?
>
> â‡’ âœ… **union/find ì—°ì‚°ì„ ì´ìš©í•´ ì‹ ì¥íŠ¸ë¦¬ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ”ì§€ ì²´í¬í•˜ë©´ ëœë‹¤.**

ìœ„ì˜ 2ê°€ì§€ âœ…ë¥¼ ë§Œì¡±í•˜ëŠ”ì§€ ì°¾ëŠ” ê²ƒì´ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì´ë‹¤.

### ğŸ“Œ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜

> [!important]
>
> â­ êµ¬í˜„ íŒ:
>
> - `List<int[]> edgeList = new ArrayList<>()` : ê°„ì„ ë¦¬ìŠ¤íŠ¸ë¡œ, ëª¨ë“  ê°„ì„ ì„ í•œ ë°”êµ¬ë‹ˆì— ë„£ëŠ”ë‹¤.
> - `int[] parents` : ê° ì •ì ì˜ ë¶€ëª¨ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¨ë‹¤.
> - `make()`: parents ë°°ì—´ ì´ˆê¸°í™”
> - `union(int a, int b)`: aì™€ bì˜ rootë¥¼ findë¡œ ì°¾ê³ , ê°™ìœ¼ë©´ `false`, ë‹¤ë¥´ë©´ ê°±ì‹  í›„ `true`ë°˜í™˜
> - `find(int a)`: aì˜ ë¶€ëª¨ ë…¸ë“œ ì°¾ê¸° `return parents[a] == a? a: (parents[a] = find(parents[a]))`
> -
>
> 1ï¸âƒ£ìµœì´ˆ ëª¨ë“  ê°„ì„ ì„ **ê°€ì¤‘ì¹˜ ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœ**ìœ¼ë¡œ ì •ë ¬
>
> 2ï¸âƒ£ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ë‚®ì€ ê°„ì„ ë¶€í„° ì„ íƒí•˜ë©´ì„œ íŠ¸ë¦¬ë¥¼ ì¦ê°€ì‹œí‚´
> ëª¨ë“  ê°„ì„ ì— ëŒ€í•´ `forë¬¸`
>
> - `union`ì„ ì‹œë„í–ˆì„ ë•Œ, `false`ë¥¼ ë¦¬í„´í•˜ë©´ `continue` (ì‚¬ì´í´ì´ ì¡´ì¬)
> - `true`ë¥¼ ë¦¬í„´í•œ ê²½ìš°, ë³‘í•©
>   - ë‘ ì •ì  ì‚¬ì´ì˜ ê°„ì„  **ê°€ì¤‘ì¹˜**ë¥¼ ëˆ„ì í•©í•˜ê³ 
>   - `cnt++`
> - ë§Œì•½ cntê°€ `N-1`ì´ ë˜ë©´ break
>
> 3ï¸âƒ£n-1ê°œì˜ ê°„ì„ ì´ ì„ íƒë  ë•Œê¹Œì§€ 2ë²ˆì„ ë°˜ë³µí•œë‹¤.

```java
public class KruskalMain {
	static int N; 		// ì •ì  ê°œìˆ˜
	static int[][] g; 	// ê°„ì„  ì •ë³´ ë°°ì—´ - int[]ê°€ edgeì •ë³´, int[][]ëŠ” ê³§ edgeì˜ 1ì°¨ì› ë°°ì—´: costë„(ê°€ì¤‘ì¹˜) ë‹´ëŠ”ë‹¤.

	/*==== ssafy_live ê°„ì„  í´ë˜ìŠ¤ ì„ ì–¸ ====*/
	static class Edge implements Comparable<Edge>{
		int from, to, weight;

		public Edge(int from, int to, int weight){
			super();
			this.from = from; this.to = to; this.weight = weight;
		}

		public int compareTo(Edge o){
			// 10 - 20 : ìŒìˆ˜ -> ë’¤ ê°’ì´ í¬ë‹¤: ê·¸ëŸ¼ ê·¸ëŒ€ë¡œ ìœ„ì¹˜ (êµí™˜ ì•ˆ ì¼ì–´ë‚¨)
			// 20 - 10 : ì–‘ìˆ˜ -> ì• ê°’ì´ í¬ë‹¤: êµí™˜
			// ì–‘ìˆ˜ - ìŒìˆ˜: ì˜¤ë²„í”Œë¡œ, ìŒìˆ˜ - ì–‘ìˆ˜: ì–¸ë”í”Œë¡œìš°ê°€ ë°œìƒí•  ìˆ˜ ìˆë‹¤.
			// ë¦¬í„´íƒ€ì… intëŠ” ì–‘ìˆ˜ëƒ, ìŒìˆ˜ëƒê°€ ì¤‘ìš”í•  ë¿, ê°’ ìì²´ëŠ” ì¤‘ìš”í•˜ì§€ ì•Šë‹¤.
			return Integer.compare(this.weight, o.weight); ; 	// ê°€ì¤‘ì¹˜ ê¸°ì¤€ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ ë˜ë„ë¡ ë¹„êµ ê²°ê³¼ ë¦¬í„´
		}
	}
	static Edge[] edgeList;
	/*==== END ====*/

	/*========union-find========*/
	/*step1. p[i] = ì§±ì˜ ì¸ë±ìŠ¤ ë²ˆí˜¸*/
	static int[] parents; 		// ì •ì ì˜ ì§±ì„ ì €ì¥í•œë‹¤.
	static void make() {	// ì •ì  ì´ˆê¸°í™”
		// parents = new int[N];
		for(int i=0; i<N; i++) parents[i] = i;
	}

	/*step2. ë‚˜ì˜ ë³´ìŠ¤(ë£¨íŠ¸ë…¸ë“œ)ë¥¼ ë¦¬í„´í•œë‹¤. */
	static int find(int a) {
		if(a == parents[a]) return a; 	// ë‚´ê°€ ëŒ€ì¥(ë£¨íŠ¸)
		return parents[a] = find(p[a]); 	// ì•„ë‹Œ ê²½ìš° í˜„ì¬ aì˜ ë¶€ëª¨ë¥¼ ë¦¬í„´í•œë‹¤. - í˜¸ì¶œê³¼ ë™ì‹œì— ì—…ë°ì´íŠ¸í•´ì¤˜ì•¼í•œë‹¤.
	}

	/*step3. ë³‘í•©í•˜ê¸°*/
	static boolean union(int a, int b) {
		int aRoot = find(a);
		int bRoot = find(b);
		if(aRoot == bRoot) return false; 	// union ë¶ˆê°€ëŠ¥ - ê°™ì€ ì¡°ì§(ê·¸ë˜í”„)ì— ì†í•¨
		// parents[bRoot] = aRoot; 			// í†µí•© - ì•ŒíŒŒë²³ ê¸°ì¤€, ì•ìª½ì— ìˆëŠ” ì•ŒíŒŒë²³ì— í†µí•©ì‹œí‚¨ë‹¤.

		// ë­í¬ ê´€ë¦¬ëŠ” ì•„ë‹˜ !! í•œìª½ìœ¼ë¡œ ì¹˜ìš°ì¹˜ëŠ” ê±¸ ë°©ì§€í•˜ê¸° ìœ„í•œ ìš”ì†Œ
		if(aRoot > bRoot) parents[bRoot] = aRoot;
		else parents[aRoot] = bRoot;

		return true; 						// union ê°€ëŠ¥ - ì„œë¡œ ë‹¤ë¥¸ ì¡°ì§
	}
	/*========END========*/

	public static void main(String[] args) throws Exception{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine(), " ");

		// step1. ì „ì²˜ë¦¬: ì…ë ¥ ë°›ê¸°
		V = Integer.parseInt(st.nextToken());
		E = Integer.parseInt(st.nextToken());

		parents = new int[V];
		edgeList = new Edge[E];

		for(int i=0; i<E; i++){
			st = new StringTokenizer(br.readLine(), " ");
			int from = Integer.parseInt(st.nextToken());
			int to = Integer.parseInt(st.nextToken());
			int weight = Integer.parseInt(st.nextToken());
		}

		// step2. ê°„ì„  ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
		Arrays.sort(edgeList);
		make();
		int result = 0; 	// ìµœì†Œì‹ ì¥íŠ¸ë¦¬ ë¹„ìš©
		int cnt = 0; 		// ì²˜ë¦¬ëœ ê°„ì„  ìˆ˜


		// step3. ê°„ì„  ì¤‘ì‹¬ìœ¼ë¡œ, fromê³¼ toê°€ í•©ì³ì§ˆ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ê³ 
		// ê°€ëŠ¥í•˜ë‹¤ë©´, ê°€ì¤‘ì¹˜ì— í•© ëˆ„ì , ê°„ì„  ê°œìˆ˜+1
		// ë§Œì•½ ê°„ì„  ê°œìˆ˜ê°€ V-1ê°œê°€ ë˜ë©´ ë.
		for(Edge e: edgeList){
			if(!union(e.from, e.to)) continue; 		// union ì‹¤íŒ¨: ì‚¬ì´í´ ë°œìƒ
			result += e.weight;
			cnt += 1;
			if(cnt == V-1) break;
		}

		System.out.println(result);

		/*=== ë‹´ë‹¹ ê°•ì‚¬ë‹˜ ì½”ë“œ=====*/
		/*
		Scanner sc = new Scanner(System.in);
		N = sc.nextInt();
		int E = sc.nextInt();

		// g = new int[E][3];
		g = new Edge[E]; (from, to, cost)
		for(int i=0; i<E; i++) {
			int from = sc.nextInt();
			int to = sc.nextInt();
			int cost = sc.nextInt();

			// g[i] = new int[] {from, to, cost}; // g[i] = new int[]{sc.nextInt(), sc.nextInt(), sc.nextInt()};

		}
		Arrays.sort(g, (o1, o2)->Integer.compare(o1[2], o2[2])); // cost ë¹„êµ; ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
		make();
		int mst = 0, cnt = 0; 	// mst: ê°€ì¤‘ì¹˜ì˜ í•©, cnt: ì„ íƒëœ ê°„ì„ ì˜ ê°œìˆ˜(ì •ì ì´ Nê°œì¼ë•Œ, MSTë¥¼ ìœ„í•´ì„œëŠ” N-1ê°œ)
		// System.out.println("p = " + Arrays.toString(p)); 		// ë”°ë¡œ ì¶”ê°€í•œ ë””ë²„ê¹… ì½”ë“œ
		for(int[] edge: g) {
			// System.out.println("p = " + Arrays.toString(p));	// ë”°ë¡œ ì¶”ê°€í•œ ë””ë²„ê¹… ì½”ë“œ
			if(union(edge[0], edge[1])) { 	// from, to ì„ íƒ í›„ í†µí•©
				mst += edge[2];
				cnt++;
			}
			if(cnt == N-1) break;
		}

		// System.out.println("p = " + Arrays.toString(p));	// ë”°ë¡œ ì¶”ê°€í•œ ë””ë²„ê¹… ì½”ë“œ
		System.out.println(mst);
		sc.close();
		*/
	}
}
/*
5 10
0 1 5
0 2 10
0 3 8
0 4 7
1 2 5
1 3 3
1 4 6
2 3 1
2 4 3
3 4 1

output==>10
===
ë””ë²„ê¹… ì½”ë“œ
p = [0, 1, 2, 3, 4]
p = [0, 1, 2, 3, 4]
p = [0, 1, 2, 2, 4]
p = [0, 1, 2, 2, 2]
p = [0, 1, 1, 2, 2]
p = [0, 1, 1, 2, 1]
p = [0, 0, 1, 2, 1]
*/
```
