# ✅ 1. 시간 복잡도 & 실행 시간 계산법  
## 📌 기본적으로 1초에 약 1억(10⁸)번 연산 가능
- 컴퓨터는 보통 1초에 약 `10⁸`(1억) 번의 연산을 수행할 수 있음.
- 따라서 `O(N)` 알고리즘이라면 **N이 10⁸ 이하**일 때 1초 안에 실행 가능.  

| 시간 복잡도 | 최대 N 값 (1초 제한) | 예제 |
|-----------|-----------------|------|
| `O(1)` (상수 시간) | 매우 큼 | 단순 계산 |
| `O(log N)` | `10¹⁸` 이상 가능 | 이진 탐색 |
| `O(N)` | 약 `10⁸` | 단순 반복문 |
| `O(N log N)` | 약 `10⁷` | 정렬 (퀵, 병합) |
| `O(N²)` | 약 `10⁴` | 중첩 루프 |
| `O(N³)` | 약 `500`~`1000` | 3중 루프 |
| `O(2^N)` | `N ≈ 20` 이하 | 백트래킹 |
| `O(N!)` | `N ≈ 10` 이하 | 순열 탐색 |

> **💡 기준:**  
> - `O(N log N)` 이하면 **N ≈ `10^7`까지 OK**  
> - `O(N²)`이면 **N이 `10⁴` 이상이면 위험**  
> - `O(2^N)`, `O(N!)`이면 **N이 20 넘어가면 절대 안됨**  

> 💡**2의 n승과 10의 n승 관계** 
> 1. `2^10 ~= 10^3`
> 2. `2^n ~= 10^(n/3.3)`

---

# ✅ 2. 메모리 제한 계산법
## 📌 기본적으로 1MB = 약 10⁶개의 정수 저장 가능
- 메모리 제한이 `512MB`이면 **약 `10⁸`개의 정수를 저장 가능**
- **각 자료형의 크기**
  
| 자료형 | 크기 (바이트) | 100만 개 저장 시 |
|--------|-------------|-----------------|
| `int` (4바이트) | 4MB | 400MB |
| `long long` (8바이트) | 8MB | 800MB |
| `bool` (1바이트) | 1MB | 100MB |
| `char` (1바이트) | 1MB | 100MB |
| `string` (길이 L) | `L` 바이트 | `L * 개수` MB |

**메모리 크기**
```plain text
1bit 
1byte = 8bit 
1KB = 1024byte 
1MB = 1024KB = 1048576byte 
64MB = 1024^2 * 64 = 64*1024KB = 67,108,864byte 
```
(주어진 메모리 크기) vs. (배열 크기) * (원소 크기)
- 정수 4byte 
- 문자 1byte

> **💡 주의할 점**  
> - 배열 크기가 `10⁷`을 넘으면 메모리 초과 위험 🚨  
> - `O(N²)` 알고리즘이 **2차원 배열(`10⁴ × 10⁴`)을 만들면 400MB!**  

---

# ✅ 3. 문제 읽을 때 빠르게 분석하는 법
1. **제한 시간 확인** ⏳  
   - `1초` → `10⁸` 연산까지 가능  
   - `2초` → `2×10⁸` 연산 가능  
   - `0.5초` → `5×10⁷` 연산까지만 가능  

2. **입력 크기(N) 확인** 🔢  
   - `N ≤ 100` → `O(N²)`, `O(N³)` 가능  
   - `N ≤ 10⁴` → `O(N log N)` 가능 (정렬 등)  
   - `N ≤ 10⁶` → `O(N)` 가능  
   - `N ≤ 10⁸` → `O(log N)`, `O(1)`만 가능  

3. **메모리 확인** 🏗  
   - `512MB` → `10⁸`개 저장 가능  
   - `256MB` → `5×10⁷`개 저장 가능  
   - `128MB` → `2.5×10⁷`개 저장 가능  

---

# ✅ 4. 예제 문제 분석 예시
### **예제 1: `N ≤ 10⁵`, 제한 시간 1초**  
✔ `O(N log N)`까지 가능 → **정렬 가능**, 이진 탐색 가능  
✔ `O(N²)`은 **불가능** (`10¹⁰` 연산으로 1초 초과)  

### **예제 2: `N ≤ 10³`, 제한 시간 1초**  
✔ `O(N²)`도 가능 (약 `10⁶` 연산)  
✔ `O(N³)`은 **위험** (`10⁹` 연산으로 초과 가능성)  

### **예제 3: `N ≤ 20`, 제한 시간 1초**  
✔ `O(2^N)` 가능 (`2²⁰ ≈ 10⁶` 연산)  
✔ `O(N!)`은 **위험** (`20! ≈ 10¹⁸` 연산)  

---

# ✅ 5. 실전 팁
1. **입력 크기(N)를 보고 O(N) 수준인지 체크!**  
2. **N² 이상이면 10⁴ 이하인지 확인!**  
3. **메모리 초과 주의 (10⁷ 개 넘는 배열은 조심!)**  
4. **시간 복잡도 계산 습관 들이기! (10⁸ 연산 기준)**  

---

# ⭐ 6. 탐색 알고리즘에서 시간 복잡도 계산하는 팁 
그래프의 정점 개수가 V이고, 간선 개수가 E일 때 
- 일반 그래프 `O(V+E)`
- 2차원 격자 탐색(1번만 방문) `O(N*M)`
- 모든 경로 탐색 (백트래킹) `O((한 정점에서 갈 수 있는 경로 개수)**(N+M))`